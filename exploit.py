#!/usr/bin/env python3
from oracle import *
from settings import *
import time

# Set the log file name
log_file = 'my_log.txt'

print(
"""
⠀⠀⠀⠀⠀⣠⣴⣶⣿⣿⠿⣷⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣶⣷⠿⣿⣿⣶⣦⣀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣶⣦⣬⡉⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠚⢉⣥⣴⣾⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀
⠀⠀⠀⡾⠿⠛⠛⠛⠛⠿⢿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⠿⠿⠛⠛⠛⠛⠿⢧⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⡿⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣠⣤⠶⠶⠶⠰⠦⣤⣀⠀⠙⣷⠀⠀⠀⠀⠀⠀⠀⢠⡿⠋⢀⣀⣤⢴⠆⠲⠶⠶⣤⣄⠀⠀⠀⠀⠀⠀⠀
⠀⠘⣆⠀⠀⢠⣾⣫⣶⣾⣿⣿⣿⣿⣷⣯⣿⣦⠈⠃⡇⠀⠀⠀⠀⢸⠘⢁⣶⣿⣵⣾⣿⣿⣿⣿⣷⣦⣝⣷⡄⠀⠀⡰⠂⠀
⠀⠀⣨⣷⣶⣿⣧⣛⣛⠿⠿⣿⢿⣿⣿⣛⣿⡿⠀⠀⡇⠀⠀⠀⠀⢸⠀⠈⢿⣟⣛⠿⢿⡿⢿⢿⢿⣛⣫⣼⡿⣶⣾⣅⡀⠀
⢀⡼⠋⠁⠀⠀⠈⠉⠛⠛⠻⠟⠸⠛⠋⠉⠁⠀⠀⢸⡇⠀⠀⠄⠀⢸⡄⠀⠀⠈⠉⠙⠛⠃⠻⠛⠛⠛⠉⠁⠀⠀⠈⠙⢧⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⡇⢠⠀⠀⠀⢸⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⡇⠀⠀⠀⠀⢸⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠟⠁⣿⠇⠀⠀⠀⠀⢸⡇⠙⢿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠰⣄⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣾⠖⡾⠁⠀⠀⣿⠀⠀⠀⠀⠀⠘⣿⠀⠀⠙⡇⢸⣷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠄⠀
⠀⠀⢻⣷⡦⣤⣤⣤⡴⠶⠿⠛⠉⠁⠀⢳⠀⢠⡀⢿⣀⠀⠀⠀⠀⣠⡟⢀⣀⢠⠇⠀⠈⠙⠛⠷⠶⢦⣤⣤⣤⢴⣾⡏⠀⠀
⠀⠀⠈⣿⣧⠙⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⢊⣙⠛⠒⠒⢛⣋⡚⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⡿⠁⣾⡿⠀⠀⠀
⠀⠀⠀⠘⣿⣇⠈⢿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡿⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⡟⠁⣼⡿⠁⠀⠀⠀
⠀⠀⠀⠀⠘⣿⣦⠀⠻⣿⣷⣦⣤⣤⣶⣶⣶⣿⣿⣿⣿⠏⠀⠀⠻⣿⣿⣿⣿⣶⣶⣶⣦⣤⣴⣿⣿⠏⢀⣼⡿⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠘⢿⣷⣄⠙⠻⠿⠿⠿⠿⠿⢿⣿⣿⣿⣁⣀⣀⣀⣀⣙⣿⣿⣿⠿⠿⠿⠿⠿⠿⠟⠁⣠⣿⡿⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠈⠻⣯⠙⢦⣀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⣠⠴⢋⣾⠟⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠙⢧⡀⠈⠉⠒⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠐⠒⠉⠁⢀⡾⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⣠⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢦⡀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⢀⡴⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
      ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
           #########################
           #   "POODLE" ATTACK     #
           #  Author: Toh Zhi Yang #
           #   Author: Yin Jian    #
           #########################
""")


def exploit(ciphertext, debug_mode):
    with open(log_file, 'w') as file:
        file.write("--------------- Start of Logs ---------------\n")

        debug_mode = debug_mode

        block_num = len(ciphertext) // NUM_BYTES
        plaintext = bytes()

        # Iterate through each byte block (from end to start)
        for block in range(block_num, 0, -1):
            cur_encrypted_block = ciphertext[(block-1)*NUM_BYTES:(block)*NUM_BYTES]
            # If we are decrypting the first ciphertext block, we will be using IV for decryption.
            if (block == 1):
                prev_encrypted_block = bytearray(IV.encode("ascii"))
            # if we are not decrypting the frist ciphertext block, we will be using the prev
            # ciphertext block for decryption
            else:
                prev_encrypted_block = ciphertext[(block-2)*NUM_BYTES:(block-1)*NUM_BYTES]
            
            attack_block = prev_encrypted_block

            cur_decrypted_block = bytearray(IV.encode("ascii"))

            # Initialise padding value
            padding = 0

            for byte_in_block in range(NUM_BYTES, 0, -1):

                padding += 1

                for guess_value in range(0,256):
                    attack_block = bytearray(attack_block)
                    #bXOR with guess and XOR with pad
                    attack_block[byte_in_block-1] = (attack_block[byte_in_block-1] + 1) % 256
                    # Append two cipherblocks together
                    joined_encrypted_block = bytes(attack_block) + cur_encrypted_block

                    # TODO: Oracle test implementation
                    # oracle_result contains (pkcs, message) -> pkcs: boolean, message: string
                    oracle_result = oracle_test(joined_encrypted_block)

                    if(oracle_result[0] == True):
                        file.write("{}\n".format(oracle_result[1]))
                        cur_decrypted_block[-padding] = attack_block[-padding] ^ prev_encrypted_block[-padding] ^ padding
                        
                        if (debug_mode == False): 
                            for num in range(1, padding + 1):
                                if (padding + 1 <= 16):
                                    # Modifies the previously guessed values in the attack block for the next padding
                                    attack_block[-num] = cur_decrypted_block[-num] ^ prev_encrypted_block[-num] ^ (padding + 1) 
                            break
                        
                        if (debug_mode == True):
                            for num in range(1, padding + 1):
                                if (padding + 1 <= 16):  
                                    attack_block[-num] = cur_decrypted_block[-num] ^ prev_encrypted_block[-num] ^ (padding + 1)
                                    
                                    file.write("block number (counting from end to start): {}\n".format(num))
                                    file.write("---------------------------------------------\n")
                                    file.write("attack block byte value: {}\n".format(hex(attack_block[-num])))
                                    file.write("current plaintext block byte value: {}\n".format(hex(cur_decrypted_block[-num])))
                                    file.write("previous ciphertext block byte value: {}\n".format(hex(prev_encrypted_block[-num])))
                                    file.write("padding to match: {}\n".format(padding + 1))
                                    file.write("{} = {} XOR {} XOR {}\n".format(attack_block[-num],cur_decrypted_block[-num],prev_encrypted_block[-num],(padding + 1)))
                                    file.write("---------------------------------------------\n")  
                            break
                    else:
                         file.write("{}\n".format(oracle_result[1]))      

            plaintext = bytes(cur_decrypted_block) + bytes(plaintext)
        file.write("---------------- End of Logs ----------------")
    file.close()
    return plaintext[:-plaintext[-1]]

def exploit_HMAC(ciphertext, HMAC):
    with open(log_file, 'w') as file:
        file.write("--------------- Start of Logs ---------------\n")

        block_num = len(ciphertext) // NUM_BYTES
        plaintext = bytes()

        # Iterate through each byte block (from end to start)
        for block in range(block_num, 0, -1):

            cur_encrypted_block = ciphertext[(block-1)*NUM_BYTES:(block)*NUM_BYTES]
            if (block == 1):
                prev_encrypted_block = bytearray(IV.encode("ascii"))

            else:
                prev_encrypted_block = ciphertext[(block-2)*NUM_BYTES:(block-1)*NUM_BYTES]
            
            # ZY: I think this attack_block can be initialise to all 0s at first, since we are just guessing the attack_block
            # one byte at a time, starting from the end of the block
            # Result: Tested + Confirmed
            attack_block = prev_encrypted_block

            # ZY: same thoughts as above
            # Result: Tested + Confirmed
            cur_decrypted_block = bytearray(IV.encode("ascii"))

            # Initialise padding value
            padding = 0

            for byte_in_block in range(NUM_BYTES, 0, -1):

                padding += 1
            
                for guess_value in range(0,256):
                    #time.sleep(0.1)
                    attack_block = bytearray(attack_block)
                    attack_block[byte_in_block-1] = (attack_block[byte_in_block-1] + 1) % 256
                    joined_encrypted_block = bytes(attack_block) + cur_encrypted_block

                    # TODO: Oracle test implementation
                    # oracle_result contains (pkcs, message) -> pkcs: boolean, message: string
                    time_start = time.perf_counter()
                    oracle_result = oracle_HMAC_test(joined_encrypted_block, HMAC)
                    time_end = time.perf_counter()
                    time_taken = time_end - time_start
                    if (time_taken > 0.02):
                        file.write("USER: {} | Server: {}\n".format(oracle_result[0], oracle_result[1]))
                        cur_decrypted_block[-padding] = attack_block[-padding] ^ prev_encrypted_block[-padding] ^ padding
                        
                        for num in range(1, padding + 1):
                            if (padding + 1 <= 16):
                                attack_block[-num] = cur_decrypted_block[-num] ^ prev_encrypted_block[-num] ^ (padding + 1) 
                        break
                    
                    else:
                         file.write("USER: {} | Server: {}\n".format(oracle_result[0], oracle_result[1]))      

            plaintext = bytes(cur_decrypted_block) + bytes(plaintext)
        file.write("---------------- End of Logs ----------------")
    file.close()
    return plaintext[:-plaintext[-1]]

def operations(number):
    switch={
    '0': """
        [Explanation of oracle function]
        We would be exploiting the oracle vulnerability by iterating through values from 0 to 255 
        (for each byte in Block X) and inputting the concatenated code
        (Block X and Current Encrypted Block) through the oracle
        to check if it is valid padding (PKCS #7)
        """,
    '1': """
        [Explanation of getting the byte of the current decrypted block]
        Definition of PKCS #7 padding:
        The value of each added byte is the number of bytes that are added, 
        i.e. N bytes, each of value N are added.
        Therefore we could deduce the byte block for the current plaintext block through this formula:
        current_plaintext_block[byte_num] = attack_block[byte_num] ^ prev_ciphertext_block[byte_num] ^ current_padding
        """,
       }
    return switch.get(number,"Invalid option")

usage = """
Usage:
  python3 exploit.py <message>         decrypts and displays the message
  python3 exploit.py HMAC <ciphertext> <HMAC> decrypts and displays the message
  python3 exploit.py -o <hex code>     displays oracle answer
  python3 exploit.py -h <number>       displays explanation for program (valid number: 0, 1)
  python3 exploit.py -d <hex code>     displays logs
Cryptographic parameters can be changed in settings.py
"""

if __name__ == '__main__':
    if len(sys.argv) == 2 : #chiffrement
        if len(sys.argv[1])%16!=0:       # code size security
            print(usage)
        else:
            print("Decrypted message: ", exploit(bytes.fromhex(sys.argv[1]), False).decode("ascii"))
    elif len(sys.argv) == 4 and sys.argv[1] == 'HMAC' : # display oracle output
        decoded_message = exploit_HMAC(bytes.fromhex(sys.argv[2]), sys.argv[3]).decode("ascii")
        print(decoded_message[:len(decoded_message)- len(sys.argv[3]) - 2])
    elif len(sys.argv) == 3 and sys.argv[1] == '-o' : # display oracle output
        print(oracle_test(bytes.fromhex(sys.argv[2])))
    elif len(sys.argv) == 3 and sys.argv[1] == '-h' : # display explanation
        print(operations(sys.argv[2]))
    elif len(sys.argv) == 3 and sys.argv[1] == '-d' : # debug purposes and log it to a file
        print("Starting Debug Mode .......")
        print("Decrypted message: ", exploit(bytes.fromhex(sys.argv[2]), True).decode("ascii"))
        print("Logs saved to my_log.txt .......")
    else:
        print(usage)